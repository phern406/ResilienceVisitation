{"ast":null,"code":"import { useContext, useState, useCallback, createElement, useMemo } from 'react';\nimport { useForceUpdate } from '@reach/utils/use-force-update';\nimport { useIsomorphicLayoutEffect } from '@reach/utils/use-isomorphic-layout-effect';\nimport { createNamedContext } from '@reach/utils/context';\nimport { noop } from '@reach/utils/noop';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar _excluded = [\"element\", \"index\"];\n\nfunction createDescendantContext(name, initialValue) {\n  if (initialValue === void 0) {\n    initialValue = {};\n  }\n\n  var descendants = [];\n  return createNamedContext(name, _extends({\n    descendants: descendants,\n    registerDescendant: noop,\n    unregisterDescendant: noop\n  }, initialValue));\n}\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\n\n\nfunction useDescendant(descendant, context, indexProp) {\n  var forceUpdate = useForceUpdate();\n\n  var _React$useContext = useContext(context),\n      registerDescendant = _React$useContext.registerDescendant,\n      unregisterDescendant = _React$useContext.unregisterDescendant,\n      descendants = _React$useContext.descendants; // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants so that\n  // everything is up-to-date before the user interacts with a collection.\n\n\n  var index = indexProp != null ? indexProp : descendants.findIndex(function (item) {\n    return item.element === descendant.element;\n  }); // Prevent any flashing\n\n  useIsomorphicLayoutEffect(function () {\n    if (!descendant.element) forceUpdate();\n    registerDescendant(_extends({}, descendant, {\n      index: index\n    }));\n    return function () {\n      unregisterDescendant(descendant.element);\n    };\n  }, [descendant, forceUpdate, index, registerDescendant, unregisterDescendant].concat(Object.values(descendant)));\n  return index;\n}\n\nfunction useDescendantsInit() {\n  return useState([]);\n}\n\nfunction useDescendants(ctx) {\n  return useContext(ctx).descendants;\n}\n\nfunction DescendantProvider(_ref) {\n  var Ctx = _ref.context,\n      children = _ref.children,\n      items = _ref.items,\n      set = _ref.set;\n  var registerDescendant = useCallback(function (_ref2) {\n    var element = _ref2.element,\n        explicitIndex = _ref2.index,\n        rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      var newItems;\n\n      if (explicitIndex != null) {\n        return [].concat(items, [_extends({}, rest, {\n          element: element,\n          index: explicitIndex\n        })]).sort(function (a, b) {\n          return a.index - b.index;\n        });\n      } else if (items.length === 0) {\n        // If there are no items, register at index 0 and bail.\n        newItems = [_extends({}, rest, {\n          element: element,\n          index: 0\n        })];\n      } else if (items.find(function (item) {\n        return item.element === element;\n      })) {\n        // If the element is already registered, just use the same array\n        newItems = items;\n      } else {\n        // When registering a descendant, we need to make sure we insert in\n        // into the array in the same order that it appears in the DOM. So as\n        // new descendants are added or maybe some are removed, we always know\n        // that the array is up-to-date and correct.\n        //\n        // So here we look at our registered descendants and see if the new\n        // element we are adding appears earlier than an existing descendant's\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\n        // the new element at this index. Because `registerDescendant` will be\n        // called in an effect every time the descendants state value changes,\n        // we should be sure that this index is accurate when descendent\n        // elements come or go from our component.\n        var index = items.findIndex(function (item) {\n          if (!item.element || !element) {\n            return false;\n          } // Does this element's DOM node appear before another item in the\n          // array in our DOM tree? If so, return true to grab the index at\n          // this point in the array so we know where to insert the new\n          // element.\n\n\n          return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);\n        });\n\n        var newItem = _extends({}, rest, {\n          element: element,\n          index: index\n        }); // If an index is not found we will push the element to the end.\n\n\n        if (index === -1) {\n          newItems = [].concat(items, [newItem]);\n        } else {\n          newItems = [].concat(items.slice(0, index), [newItem], items.slice(index));\n        }\n      }\n\n      return newItems.map(function (item, index) {\n        return _extends({}, item, {\n          index: index\n        });\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  var unregisterDescendant = useCallback(function (element) {\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      return items.filter(function (item) {\n        return element !== item.element;\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  return /*#__PURE__*/createElement(Ctx.Provider, {\n    value: useMemo(function () {\n      return {\n        descendants: items,\n        registerDescendant: registerDescendant,\n        unregisterDescendant: unregisterDescendant\n      };\n    }, [items, registerDescendant, unregisterDescendant])\n  }, children);\n}\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\n\n\nfunction useDescendantKeyDown(context, options) {\n  var _React$useContext2 = useContext(context),\n      descendants = _React$useContext2.descendants;\n\n  var callback = options.callback,\n      currentIndex = options.currentIndex,\n      filter = options.filter,\n      _options$key = options.key,\n      key = _options$key === void 0 ? \"index\" : _options$key,\n      _options$orientation = options.orientation,\n      orientation = _options$orientation === void 0 ? \"vertical\" : _options$orientation,\n      _options$rotate = options.rotate,\n      rotate = _options$rotate === void 0 ? true : _options$rotate,\n      _options$rtl = options.rtl,\n      rtl = _options$rtl === void 0 ? false : _options$rtl;\n  return function handleKeyDown(event) {\n    if (![\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"PageUp\", \"PageDown\", \"Home\", \"End\"].includes(event.key)) {\n      return;\n    }\n\n    var index = currentIndex != null ? currentIndex : -1; // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n\n    var selectableDescendants = filter ? descendants.filter(filter) : descendants; // We need some options for any of this to work!\n\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    var selectableIndex = selectableDescendants.findIndex(function (descendant) {\n      return descendant.index === currentIndex;\n    });\n\n    function getNextOption() {\n      var atBottom = index === getLastOption().index;\n      return atBottom ? rotate ? getFirstOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      var atTop = index === getFirstOption().index;\n      return atTop ? rotate ? getLastOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex - 1 + selectableDescendants.length) % selectableDescendants.length];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n\n        break;\n\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n\n        break;\n\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n\n        break;\n\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n\n        break;\n\n      case \"PageUp\":\n        event.preventDefault();\n        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n\n      case \"Home\":\n        event.preventDefault();\n        var first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n\n      case \"PageDown\":\n        event.preventDefault();\n        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n\n      case \"End\":\n        event.preventDefault();\n        var last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nexport { DescendantProvider, createDescendantContext, useDescendant, useDescendantKeyDown, useDescendants, useDescendantsInit };","map":{"version":3,"sources":["/Users/mr.hern/Desktop/Bethel School. FInal Pro./Old-To-New/Old-New/node_modules/@reach/descendants/dist/reach-descendants.esm.js"],"names":["useContext","useState","useCallback","createElement","useMemo","useForceUpdate","useIsomorphicLayoutEffect","createNamedContext","noop","_objectWithoutPropertiesLoose","source","excluded","target","sourceKeys","Object","keys","key","i","length","indexOf","_extends","assign","arguments","prototype","hasOwnProperty","call","apply","_excluded","createDescendantContext","name","initialValue","descendants","registerDescendant","unregisterDescendant","useDescendant","descendant","context","indexProp","forceUpdate","_React$useContext","index","findIndex","item","element","concat","values","useDescendantsInit","useDescendants","ctx","DescendantProvider","_ref","Ctx","children","items","set","_ref2","explicitIndex","rest","newItems","sort","a","b","find","Boolean","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","newItem","slice","map","filter","Provider","value","useDescendantKeyDown","options","_React$useContext2","callback","currentIndex","_options$key","_options$orientation","orientation","_options$rotate","rotate","_options$rtl","rtl","handleKeyDown","event","includes","selectableDescendants","selectableIndex","getNextOption","atBottom","getLastOption","getFirstOption","getPreviousOption","atTop","preventDefault","next","prev","nextOrPrev","prevOrNext","prevOrFirst","ctrlKey","first","nextOrLast","last"],"mappings":"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","sourcesContent":["import { useContext, useState, useCallback, createElement, useMemo } from 'react';\nimport { useForceUpdate } from '@reach/utils/use-force-update';\nimport { useIsomorphicLayoutEffect } from '@reach/utils/use-isomorphic-layout-effect';\nimport { createNamedContext } from '@reach/utils/context';\nimport { noop } from '@reach/utils/noop';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar _excluded = [\"element\", \"index\"];\n\nfunction createDescendantContext(name, initialValue) {\n  if (initialValue === void 0) {\n    initialValue = {};\n  }\n\n  var descendants = [];\n  return createNamedContext(name, _extends({\n    descendants: descendants,\n    registerDescendant: noop,\n    unregisterDescendant: noop\n  }, initialValue));\n}\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\n\n\nfunction useDescendant(descendant, context, indexProp) {\n  var forceUpdate = useForceUpdate();\n\n  var _React$useContext = useContext(context),\n      registerDescendant = _React$useContext.registerDescendant,\n      unregisterDescendant = _React$useContext.unregisterDescendant,\n      descendants = _React$useContext.descendants; // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants so that\n  // everything is up-to-date before the user interacts with a collection.\n\n\n  var index = indexProp != null ? indexProp : descendants.findIndex(function (item) {\n    return item.element === descendant.element;\n  }); // Prevent any flashing\n\n  useIsomorphicLayoutEffect(function () {\n    if (!descendant.element) forceUpdate();\n    registerDescendant(_extends({}, descendant, {\n      index: index\n    }));\n    return function () {\n      unregisterDescendant(descendant.element);\n    };\n  }, [descendant, forceUpdate, index, registerDescendant, unregisterDescendant].concat(Object.values(descendant)));\n  return index;\n}\n\nfunction useDescendantsInit() {\n  return useState([]);\n}\n\nfunction useDescendants(ctx) {\n  return useContext(ctx).descendants;\n}\n\nfunction DescendantProvider(_ref) {\n  var Ctx = _ref.context,\n      children = _ref.children,\n      items = _ref.items,\n      set = _ref.set;\n  var registerDescendant = useCallback(function (_ref2) {\n    var element = _ref2.element,\n        explicitIndex = _ref2.index,\n        rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      var newItems;\n\n      if (explicitIndex != null) {\n        return [].concat(items, [_extends({}, rest, {\n          element: element,\n          index: explicitIndex\n        })]).sort(function (a, b) {\n          return a.index - b.index;\n        });\n      } else if (items.length === 0) {\n        // If there are no items, register at index 0 and bail.\n        newItems = [_extends({}, rest, {\n          element: element,\n          index: 0\n        })];\n      } else if (items.find(function (item) {\n        return item.element === element;\n      })) {\n        // If the element is already registered, just use the same array\n        newItems = items;\n      } else {\n        // When registering a descendant, we need to make sure we insert in\n        // into the array in the same order that it appears in the DOM. So as\n        // new descendants are added or maybe some are removed, we always know\n        // that the array is up-to-date and correct.\n        //\n        // So here we look at our registered descendants and see if the new\n        // element we are adding appears earlier than an existing descendant's\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\n        // the new element at this index. Because `registerDescendant` will be\n        // called in an effect every time the descendants state value changes,\n        // we should be sure that this index is accurate when descendent\n        // elements come or go from our component.\n        var index = items.findIndex(function (item) {\n          if (!item.element || !element) {\n            return false;\n          } // Does this element's DOM node appear before another item in the\n          // array in our DOM tree? If so, return true to grab the index at\n          // this point in the array so we know where to insert the new\n          // element.\n\n\n          return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);\n        });\n\n        var newItem = _extends({}, rest, {\n          element: element,\n          index: index\n        }); // If an index is not found we will push the element to the end.\n\n\n        if (index === -1) {\n          newItems = [].concat(items, [newItem]);\n        } else {\n          newItems = [].concat(items.slice(0, index), [newItem], items.slice(index));\n        }\n      }\n\n      return newItems.map(function (item, index) {\n        return _extends({}, item, {\n          index: index\n        });\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  var unregisterDescendant = useCallback(function (element) {\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      return items.filter(function (item) {\n        return element !== item.element;\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  return /*#__PURE__*/createElement(Ctx.Provider, {\n    value: useMemo(function () {\n      return {\n        descendants: items,\n        registerDescendant: registerDescendant,\n        unregisterDescendant: unregisterDescendant\n      };\n    }, [items, registerDescendant, unregisterDescendant])\n  }, children);\n}\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\n\n\nfunction useDescendantKeyDown(context, options) {\n  var _React$useContext2 = useContext(context),\n      descendants = _React$useContext2.descendants;\n\n  var callback = options.callback,\n      currentIndex = options.currentIndex,\n      filter = options.filter,\n      _options$key = options.key,\n      key = _options$key === void 0 ? \"index\" : _options$key,\n      _options$orientation = options.orientation,\n      orientation = _options$orientation === void 0 ? \"vertical\" : _options$orientation,\n      _options$rotate = options.rotate,\n      rotate = _options$rotate === void 0 ? true : _options$rotate,\n      _options$rtl = options.rtl,\n      rtl = _options$rtl === void 0 ? false : _options$rtl;\n  return function handleKeyDown(event) {\n    if (![\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"PageUp\", \"PageDown\", \"Home\", \"End\"].includes(event.key)) {\n      return;\n    }\n\n    var index = currentIndex != null ? currentIndex : -1; // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n\n    var selectableDescendants = filter ? descendants.filter(filter) : descendants; // We need some options for any of this to work!\n\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    var selectableIndex = selectableDescendants.findIndex(function (descendant) {\n      return descendant.index === currentIndex;\n    });\n\n    function getNextOption() {\n      var atBottom = index === getLastOption().index;\n      return atBottom ? rotate ? getFirstOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      var atTop = index === getFirstOption().index;\n      return atTop ? rotate ? getLastOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex - 1 + selectableDescendants.length) % selectableDescendants.length];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n\n        break;\n\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n\n        break;\n\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n\n        break;\n\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n\n        break;\n\n      case \"PageUp\":\n        event.preventDefault();\n        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n\n      case \"Home\":\n        event.preventDefault();\n        var first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n\n      case \"PageDown\":\n        event.preventDefault();\n        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n\n      case \"End\":\n        event.preventDefault();\n        var last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\nexport { DescendantProvider, createDescendantContext, useDescendant, useDescendantKeyDown, useDescendants, useDescendantsInit };\n"]},"metadata":{},"sourceType":"module"}